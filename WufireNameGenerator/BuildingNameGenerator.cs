// ------------------------------------------------------------------------------//  <autogenerated>//      This code was generated by a tool.//      Mono Runtime Version: 4.0.30319.1// //      Changes to this file may cause incorrect behavior and will be lost if //      the code is regenerated.//  </autogenerated>// ------------------------------------------------------------------------------using System;using ICities;using System.Collections.Generic;using ColossalFramework.Math;namespace WufireNameGenerator{  public class BuildingNameGenerator  {    const int MAX_BUILDING_NAME_LENGTH = 32;    private static BuildingNameData bnd;    public BuildingNameGenerator ()    {          }    public static void Initialize() {      bnd = new BuildingNameData();    }    public static string GenerateName(ItemClass.Service service, Randomizer randomizer) {      return _generateNameHelper(bnd.BuildingNameDataForSubService(service.ToString()), randomizer);    }    public static string GenerateName(ItemClass.SubService subservice, Randomizer randomizer) {      return _generateNameHelper(bnd.BuildingNameDataForSubService(subservice.ToString()), randomizer);    }        private static string _generateNameHelper(List<NamePart> nameParts, Randomizer randomizer) {      List<BuildableNamePart>bnpList = new List<BuildableNamePart>();      int nameLength = 0;      for (int i = 0; i < nameParts.Count; i++) {        NamePart part = nameParts[i];        bool buildableIsOptional = false;                if(part.isOptional) {          if (randomizer.Int32(10) > 5) {            continue;          }          buildableIsOptional = true;        }                string newWord = part.nameList[randomizer.Int32((uint)part.nameList.Count)];        if (! newWord.Trim().Equals("")) {          newWord += " ";        }        BuildableNamePart bnp = new BuildableNamePart(buildableIsOptional, newWord);        bnpList.Add(bnp);        nameLength += newWord.Length;      }      return _bestFitName(bnpList, nameLength);    }    private static string _bestFitName(List<BuildableNamePart> bnpList, int nameLength) {      if (nameLength <= MAX_BUILDING_NAME_LENGTH) {        return _assembleName(bnpList);      }      foreach(BuildableNamePart bnp in bnpList) {        if(bnp.optional) {          bnpList.Remove(bnp);          return _bestFitName(bnpList, nameLength - bnp.word.Length);        }      }      // If we get here, we've run out of optionals.      return _assembleName(bnpList);    }    private static string _assembleName(List<BuildableNamePart> bnpList) {      string finalName = "";      foreach(BuildableNamePart bnp in bnpList) {        finalName += bnp.word;      }      return finalName.Trim();    }    private struct BuildableNamePart{      public bool optional;      public string word;      public BuildableNamePart(bool opt, string str) {        this.optional = opt;        this.word = str;      }    }   }}